#Deadlock
###一、实验内容

Deadlock

###二、实验原理

死锁就是两个或者多个进程，互相请求对方占有的资源。
互斥条件：一个资源每次只能被一个进程使用
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系
</br>
</br>

###三、实验截图

首先我们需要将JAVA代码抄写下来，然后写上bat批处理文件。我们先在命令行编译JAVA文件
    
    javac Deadlock.java

得到了Deadlock.class文件之后，我们就可以直接运行Deadlock.bat批处理文件了。首先我们不做任何改动得运行该批处理文件。我们先看看该批处理文件的内容。

![](https://github.com/Valesail1/ES2016_14353414/blob/master/Deadlock3.png)

该处理文件的作用就是将我们的Runnable代码循环1000次。我们可以通过改动这里的数字来变换循环次数，目的只要达到能够死锁。

![](https://github.com/Valesail1/ES2016_14353414/blob/master/Deadlock1.png)

运行之后我们可以发现改程序在循环第七次的时候就死锁了。我们再重新运行一次，不用修改count，因为只需要达到死锁就好了。这次的运行结果如下。

![](https://github.com/Valesail1/ES2016_14353414/blob/master/Deadlock2.png)

这次的程序在第499次的时候就死锁了。
</br>
</br>
###四、实验感想与问答
####1.产生死锁的四个必要条件
1）互斥条件，一个资源一次只能被一个进程所使用，如果能同时满足所有进程的话，就不会死锁了。</br>
2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</br>
3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺，否则会打乱进程之间运行的顺序</br>
4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</br>
</br>
####2.产生以上死锁的原因
我们的代码产生了上面的死锁，其根本原因：
</br>
在主函数中我们发现了这么一段：
    
    a.methodA(b);

然后在Runnable的run函数里面有这么一段：

    public void run(){
		b.methodB(a);
	}

这两个method函数都分别调用了：

    synchronized void methodA(B b){
			b.last();		
		}
以及

    synchronized void methodB(A a){
			a.last();		
		}

这时候我们可以发现，当我们运行主函数的时候，新开一个线程用来运行run函数，这两个线程是同时在运行，但是在运行a.methodA(b)的时候，这时候需要运行b.last()；这个函数是需要用到b的资源的，但这时候b的资源正在被占着而申请不成功，而这时候b也在运行申请a的资源。也就是说，当a和b同时运行的时候，a，b互相申请资源的时候就会死锁，只有当其中一个线程完全运行结束再运行另外一个线程的时候，就不会死锁，这也就是为什么死锁的次数是个随机数的原因。